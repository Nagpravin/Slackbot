import json
import google.generativeai as genai
import config
from sklearn.cluster import KMeans
import numpy as np

# --- Global Gemini Configuration ---
genai.configure(api_key=config.GEMINI_API_KEY)
content_model=genai.GenerativeModel("gemini-2.5-flash")
# The genai module itself will be used for embed_content

def get_embeddings(keywords):
    try:
        # Use the global genai module for embedding
        response=genai.embed_content(
            model='text-embedding-004',
            content=keywords
        )
        vecs=response['embedding']
        return np.array(vecs)
    except Exception as e:
        print("embedding err:",e)
        # 768 is the standard dimension for text-embedding-004
        return np.zeros((len(keywords),768))

def make_clusters(keywords):
    if len(keywords)==0:
        return {}

    vecs=get_embeddings(keywords)
    if len(keywords)<=5:n=1
    elif len(keywords)<=10:n=2
    elif len(keywords)<=20:n=3
    else:n=4

    if n==1:
        return {"Topic 1":keywords}

    try:
        print("Embedding keywords for K-Means clustering...")
        
        kmeans=KMeans(n_clusters=n,random_state=0,n_init=10)
        # Suppress the ConvergenceWarning that occurs with very few clusters
        if n==1:
             kmeans=KMeans(n_clusters=n,random_state=0,n_init=1)
        
        kmeans.fit(vecs)
        labels=kmeans.labels_
        
        groups_from_kmeans={i:[]for i in range(n)}
        for keyword,label in zip(keywords,labels):
            groups_from_kmeans[label].append(keyword)

        cluster_list=[]
        for group_id,kws in groups_from_kmeans.items():
            if kws:
                cluster_list.append(f"Cluster ID {group_id}: {', '.join(kws)}")

    except Exception as e:
        print(f"K-Means or Embedding Error: {e}. Falling back to LLM-only clustering.")
        return _make_clusters_with_llm(keywords,n,llm_only=True)

    prompt=f"""You are an expert SEO and content strategist. Your task is to analyze the following {n} raw keyword groups generated by K-Means clustering.
1. For each group, assign a concise, descriptive, and SEO-friendly title (cluster_name).
2. Do NOT change the keywords within each group.
3. Ensure the 'keywords' array for each object matches the input list exactly.
4. Return only the JSON object requested by the schema.

Groups to name:
{'\n'.join(cluster_list)}
"""
    return _make_clusters_with_llm(prompt,n,groups_from_kmeans)

def _make_clusters_with_llm(prompt_or_keywords,n,groups_from_kmeans=None,llm_only=False):
    output_schema={"type":"object","properties":{"clusters":{"type":"array","items":{"type":"object","properties":{"cluster_name":{"type":"string","description":"A concise, descriptive name for the keyword group."},"keywords":{"type":"array","items":{"type":"string"},"description":"The list of keywords belonging to this group."}},"required":["cluster_name","keywords"]}}},"required":["clusters"]}

    if llm_only:
        keywords=prompt_or_keywords
        prompt=f"""You are an expert SEO and content strategist. Your task is to group the following list of
keywords into {n} distinct, semantically similar clusters.

1. Assign a descriptive, short title for each cluster.
2. Place all given keywords into one of the {n} clusters. Do not invent new keywords.
3. Return only the JSON object requested by the schema.

Keywords to cluster: {', '.join(keywords)}
"""
    else:
        prompt=prompt_or_keywords
    
    # --- FIX: Using the simpler 'generation_config' dictionary for structured output ---
    generation_config_dict = {
        "response_mime_type": "application/json",
        "response_schema": output_schema,
        "temperature": 0.1
    }

    try:
        response=content_model.generate_content(
            prompt,
            generation_config=generation_config_dict 
        )

        data=json.loads(response.text)
        
        groups={}
        for cluster_data in data.get('clusters',[]):
            name=cluster_data.get('cluster_name',f"Unnamed Cluster {len(groups)+1}")
            keywords_list=cluster_data.get('keywords',[])

            groups[name]=keywords_list
            
        return groups

    except Exception as e:
        print(f"Gemini API Error during clustering/naming: {e}")
        return {"API Error":[f"Could not cluster keywords: {str(e)}"]}
